// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package follows

import (
	"context"
	"database/sql"
	"time"
)

const followUser = `-- name: FollowUser :one
WITH f AS (
	INSERT INTO follows (follower_user_id, following_user_id, follow_date)
	VALUES ($1, $2, $3)
	ON CONFLICT (follower_user_id, following_user_id)
	DO UPDATE SET follow_date = EXCLUDED.follow_date
	RETURNING follower_user_id, following_user_id, follow_date, unfollow_date
)
SELECT f.follower_user_id, f.following_user_id, f.follow_date, f.unfollow_date, u.email_verified, u.password_changed_at, u.email, u.password, u.id, u.family_name, u.type, u.given_name, u.username
FROM f
JOIN users u ON f.following_user_id = u.id
`

type FollowUserParams struct {
	FollowerUserID  string
	FollowingUserID string
	FollowDate      time.Time
}

type FollowUserRow struct {
	FollowerUserID    string
	FollowingUserID   string
	FollowDate        time.Time
	UnfollowDate      sql.NullTime
	EmailVerified     sql.NullBool
	PasswordChangedAt sql.NullTime
	Email             string
	Password          sql.NullString
	ID                string
	FamilyName        sql.NullString
	Type              string
	GivenName         sql.NullString
	Username          sql.NullString
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (FollowUserRow, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerUserID, arg.FollowingUserID, arg.FollowDate)
	var i FollowUserRow
	err := row.Scan(
		&i.FollowerUserID,
		&i.FollowingUserID,
		&i.FollowDate,
		&i.UnfollowDate,
		&i.EmailVerified,
		&i.PasswordChangedAt,
		&i.Email,
		&i.Password,
		&i.ID,
		&i.FamilyName,
		&i.Type,
		&i.GivenName,
		&i.Username,
	)
	return i, err
}

const getFollowers = `-- name: GetFollowers :many
SELECT f.follower_user_id, f.following_user_id, f.follow_date, f.unfollow_date, u.email_verified, u.password_changed_at, u.email, u.password, u.id, u.family_name, u.type, u.given_name, u.username FROM follows f
JOIN users u ON f.follower_user_id = u.id
WHERE following_user_id=$1
AND follow_date > unfollow_date OR unfollow_date IS NULL
`

type GetFollowersRow struct {
	FollowerUserID    string
	FollowingUserID   string
	FollowDate        time.Time
	UnfollowDate      sql.NullTime
	EmailVerified     sql.NullBool
	PasswordChangedAt sql.NullTime
	Email             string
	Password          sql.NullString
	ID                string
	FamilyName        sql.NullString
	Type              string
	GivenName         sql.NullString
	Username          sql.NullString
}

func (q *Queries) GetFollowers(ctx context.Context, followingUserID string) ([]GetFollowersRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowers, followingUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowersRow
	for rows.Next() {
		var i GetFollowersRow
		if err := rows.Scan(
			&i.FollowerUserID,
			&i.FollowingUserID,
			&i.FollowDate,
			&i.UnfollowDate,
			&i.EmailVerified,
			&i.PasswordChangedAt,
			&i.Email,
			&i.Password,
			&i.ID,
			&i.FamilyName,
			&i.Type,
			&i.GivenName,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowersCount = `-- name: GetFollowersCount :one
SELECT COUNT(*) FROM follows 
WHERE following_user_id=$1
AND follow_date > unfollow_date  OR unfollow_date IS NULL
`

func (q *Queries) GetFollowersCount(ctx context.Context, followingUserID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFollowersCount, followingUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFollowing = `-- name: GetFollowing :many
SELECT f.follower_user_id, f.following_user_id, f.follow_date, f.unfollow_date, u.email_verified, u.password_changed_at, u.email, u.password, u.id, u.family_name, u.type, u.given_name, u.username FROM follows f
JOIN users u ON f.following_user_id = u.id
WHERE follower_user_id=$1
AND follow_date > unfollow_date OR unfollow_date IS NULL
`

type GetFollowingRow struct {
	FollowerUserID    string
	FollowingUserID   string
	FollowDate        time.Time
	UnfollowDate      sql.NullTime
	EmailVerified     sql.NullBool
	PasswordChangedAt sql.NullTime
	Email             string
	Password          sql.NullString
	ID                string
	FamilyName        sql.NullString
	Type              string
	GivenName         sql.NullString
	Username          sql.NullString
}

func (q *Queries) GetFollowing(ctx context.Context, followerUserID string) ([]GetFollowingRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowing, followerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowingRow
	for rows.Next() {
		var i GetFollowingRow
		if err := rows.Scan(
			&i.FollowerUserID,
			&i.FollowingUserID,
			&i.FollowDate,
			&i.UnfollowDate,
			&i.EmailVerified,
			&i.PasswordChangedAt,
			&i.Email,
			&i.Password,
			&i.ID,
			&i.FamilyName,
			&i.Type,
			&i.GivenName,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowingCount = `-- name: GetFollowingCount :one
SELECT COUNT(*) FROM follows 
WHERE follower_user_id=$1
AND follow_date > unfollow_date  OR unfollow_date IS NULL
`

func (q *Queries) GetFollowingCount(ctx context.Context, followerUserID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFollowingCount, followerUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isFollowingUser = `-- name: IsFollowingUser :one
SELECT EXISTS(SELECT follower_user_id, following_user_id, follow_date, unfollow_date FROM follows WHERE follower_user_id=$1 AND following_user_id=$2 AND (follow_date > unfollow_date OR unfollow_date IS NULL))
`

type IsFollowingUserParams struct {
	FollowerUserID  string
	FollowingUserID string
}

func (q *Queries) IsFollowingUser(ctx context.Context, arg IsFollowingUserParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isFollowingUser, arg.FollowerUserID, arg.FollowingUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const unfollowUser = `-- name: UnfollowUser :one
UPDATE follows
SET unfollow_date=$1
FROM users u
WHERE 
following_user_id = u.id
AND follower_user_id=$2
AND following_user_id=$3
RETURNING email_verified, password_changed_at, email, password, id, family_name, type, given_name, username, follower_user_id, following_user_id, follow_date, unfollow_date
`

type UnfollowUserParams struct {
	UnfollowDate    sql.NullTime
	FollowerUserID  string
	FollowingUserID string
}

type UnfollowUserRow struct {
	EmailVerified     sql.NullBool
	PasswordChangedAt sql.NullTime
	Email             string
	Password          sql.NullString
	ID                string
	FamilyName        sql.NullString
	Type              string
	GivenName         sql.NullString
	Username          sql.NullString
	FollowerUserID    string
	FollowingUserID   string
	FollowDate        time.Time
	UnfollowDate      sql.NullTime
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UnfollowUserRow, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.UnfollowDate, arg.FollowerUserID, arg.FollowingUserID)
	var i UnfollowUserRow
	err := row.Scan(
		&i.EmailVerified,
		&i.PasswordChangedAt,
		&i.Email,
		&i.Password,
		&i.ID,
		&i.FamilyName,
		&i.Type,
		&i.GivenName,
		&i.Username,
		&i.FollowerUserID,
		&i.FollowingUserID,
		&i.FollowDate,
		&i.UnfollowDate,
	)
	return i, err
}
