// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package notifications

import (
	"context"
	"database/sql"
	"time"
)

const createNotification = `-- name: CreateNotification :one
WITH n AS (
    INSERT INTO notifications 
	(id, user_id_to_notify, user_id_who_fired_event, trigger_id, event_id, date, content)
	VALUES ($1, $2, $3, $4, $5, $6, $7)
	RETURNING id, user_id_to_notify, user_id_who_fired_event, date, read, trigger_id, event_id, content
)
SELECT n.id, n.user_id_to_notify, n.user_id_who_fired_event, n.date, n.read, n.trigger_id, n.event_id, n.content, u.username
FROM n
JOIN users u ON n.user_id_who_fired_event = u.id
`

type CreateNotificationParams struct {
	ID                  string
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	TriggerID           sql.NullString
	EventID             string
	Date                time.Time
	Content             sql.NullString
}

type CreateNotificationRow struct {
	ID                  string
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	Date                time.Time
	Read                bool
	TriggerID           sql.NullString
	EventID             string
	Content             sql.NullString
	Username            sql.NullString
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (CreateNotificationRow, error) {
	row := q.db.QueryRowContext(ctx, createNotification,
		arg.ID,
		arg.UserIDToNotify,
		arg.UserIDWhoFiredEvent,
		arg.TriggerID,
		arg.EventID,
		arg.Date,
		arg.Content,
	)
	var i CreateNotificationRow
	err := row.Scan(
		&i.ID,
		&i.UserIDToNotify,
		&i.UserIDWhoFiredEvent,
		&i.Date,
		&i.Read,
		&i.TriggerID,
		&i.EventID,
		&i.Content,
		&i.Username,
	)
	return i, err
}

const getAllNotifications = `-- name: GetAllNotifications :many
SELECT n.id, n.user_id_to_notify, n.user_id_who_fired_event, n.date, n.read, n.trigger_id, n.event_id, n.content, u.username FROM notifications n JOIN users u
ON u.id = n.user_id_who_fired_event
WHERE n.user_id_to_notify=$1 AND n.read=true
UNION ALL
SELECT n.id, n.user_id_to_notify, n.user_id_who_fired_event, n.date, n.read, n.trigger_id, n.event_id, n.content, u.username FROM notifications n JOIN users u
ON u.id = n.user_id_who_fired_event
WHERE n.user_id_to_notify=$1 AND n.read=false
ORDER BY date DESC
`

type GetAllNotificationsRow struct {
	ID                  string
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	Date                time.Time
	Read                bool
	TriggerID           sql.NullString
	EventID             string
	Content             sql.NullString
	Username            sql.NullString
}

func (q *Queries) GetAllNotifications(ctx context.Context, userIDToNotify string) ([]GetAllNotificationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllNotifications, userIDToNotify)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllNotificationsRow
	for rows.Next() {
		var i GetAllNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserIDToNotify,
			&i.UserIDWhoFiredEvent,
			&i.Date,
			&i.Read,
			&i.TriggerID,
			&i.EventID,
			&i.Content,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotification = `-- name: GetNotification :one
SELECT n.id, n.user_id_to_notify, n.user_id_who_fired_event, n.date, n.read, n.trigger_id, n.event_id, n.content, u.username FROM notifications n JOIN users u
ON u.id = n.user_id_who_fired_event
WHERE
user_id_to_notify=$1 AND
user_id_who_fired_event=$2 AND
trigger_id=$3 AND
event_id=$4
`

type GetNotificationParams struct {
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	TriggerID           sql.NullString
	EventID             string
}

type GetNotificationRow struct {
	ID                  string
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	Date                time.Time
	Read                bool
	TriggerID           sql.NullString
	EventID             string
	Content             sql.NullString
	Username            sql.NullString
}

func (q *Queries) GetNotification(ctx context.Context, arg GetNotificationParams) (GetNotificationRow, error) {
	row := q.db.QueryRowContext(ctx, getNotification,
		arg.UserIDToNotify,
		arg.UserIDWhoFiredEvent,
		arg.TriggerID,
		arg.EventID,
	)
	var i GetNotificationRow
	err := row.Scan(
		&i.ID,
		&i.UserIDToNotify,
		&i.UserIDWhoFiredEvent,
		&i.Date,
		&i.Read,
		&i.TriggerID,
		&i.EventID,
		&i.Content,
		&i.Username,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT n.id, n.user_id_to_notify, n.user_id_who_fired_event, n.date, n.read, n.trigger_id, n.event_id, n.content, u.username FROM notifications n JOIN users u
ON u.id = n.user_id_who_fired_event
WHERE n.id=$1
`

type GetNotificationByIDRow struct {
	ID                  string
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	Date                time.Time
	Read                bool
	TriggerID           sql.NullString
	EventID             string
	Content             sql.NullString
	Username            sql.NullString
}

func (q *Queries) GetNotificationByID(ctx context.Context, id string) (GetNotificationByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByID, id)
	var i GetNotificationByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserIDToNotify,
		&i.UserIDWhoFiredEvent,
		&i.Date,
		&i.Read,
		&i.TriggerID,
		&i.EventID,
		&i.Content,
		&i.Username,
	)
	return i, err
}

const getUnreadNotifications = `-- name: GetUnreadNotifications :many
SELECT n.id, n.user_id_to_notify, n.user_id_who_fired_event, n.date, n.read, n.trigger_id, n.event_id, n.content, u.username FROM notifications n JOIN users u
ON u.id = n.user_id_who_fired_event
WHERE user_id_to_notify=$1 AND read=false ORDER BY date DESC
`

type GetUnreadNotificationsRow struct {
	ID                  string
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	Date                time.Time
	Read                bool
	TriggerID           sql.NullString
	EventID             string
	Content             sql.NullString
	Username            sql.NullString
}

func (q *Queries) GetUnreadNotifications(ctx context.Context, userIDToNotify string) ([]GetUnreadNotificationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadNotifications, userIDToNotify)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnreadNotificationsRow
	for rows.Next() {
		var i GetUnreadNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserIDToNotify,
			&i.UserIDWhoFiredEvent,
			&i.Date,
			&i.Read,
			&i.TriggerID,
			&i.EventID,
			&i.Content,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notificationAlreadyExists = `-- name: NotificationAlreadyExists :one
SELECT EXISTS(
	SELECT id FROM notifications
	WHERE
	user_id_to_notify=$1 AND
	user_id_who_fired_event=$2 AND
	trigger_id=$3 AND
	event_id=$4
)
`

type NotificationAlreadyExistsParams struct {
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	TriggerID           sql.NullString
	EventID             string
}

func (q *Queries) NotificationAlreadyExists(ctx context.Context, arg NotificationAlreadyExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, notificationAlreadyExists,
		arg.UserIDToNotify,
		arg.UserIDWhoFiredEvent,
		arg.TriggerID,
		arg.EventID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const readNotification = `-- name: ReadNotification :one
WITH n AS (
	UPDATE notifications ns
	SET read=true 
	WHERE ns.id=$1
	RETURNING id, user_id_to_notify, user_id_who_fired_event, date, read, trigger_id, event_id, content
)
SELECT n.id, n.user_id_to_notify, n.user_id_who_fired_event, n.date, n.read, n.trigger_id, n.event_id, n.content, u.username
FROM n
JOIN users u ON n.user_id_who_fired_event = u.id
`

type ReadNotificationRow struct {
	ID                  string
	UserIDToNotify      string
	UserIDWhoFiredEvent string
	Date                time.Time
	Read                bool
	TriggerID           sql.NullString
	EventID             string
	Content             sql.NullString
	Username            sql.NullString
}

func (q *Queries) ReadNotification(ctx context.Context, id string) (ReadNotificationRow, error) {
	row := q.db.QueryRowContext(ctx, readNotification, id)
	var i ReadNotificationRow
	err := row.Scan(
		&i.ID,
		&i.UserIDToNotify,
		&i.UserIDWhoFiredEvent,
		&i.Date,
		&i.Read,
		&i.TriggerID,
		&i.EventID,
		&i.Content,
		&i.Username,
	)
	return i, err
}
