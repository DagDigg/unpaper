// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package posts

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (id, author, message, audio, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING likes, audio, id, author, message, user_ids_who_likes, created_at
`

type CreatePostParams struct {
	ID        string
	Author    string
	Message   string
	Audio     json.RawMessage
	CreatedAt sql.NullTime
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.Author,
		arg.Message,
		arg.Audio,
		arg.CreatedAt,
	)
	var i Post
	err := row.Scan(
		&i.Likes,
		&i.Audio,
		&i.ID,
		&i.Author,
		&i.Message,
		pq.Array(&i.UserIdsWhoLikes),
		&i.CreatedAt,
	)
	return i, err
}

const getPost = `-- name: GetPost :one
SELECT likes, audio, id, author, message, user_ids_who_likes, created_at from posts
WHERE id = $1
`

func (q *Queries) GetPost(ctx context.Context, id string) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.Likes,
		&i.Audio,
		&i.ID,
		&i.Author,
		&i.Message,
		pq.Array(&i.UserIdsWhoLikes),
		&i.CreatedAt,
	)
	return i, err
}

const getPosts = `-- name: GetPosts :many
SELECT likes, audio, id, author, message, user_ids_who_likes, created_at from posts
`

func (q *Queries) GetPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.Likes,
			&i.Audio,
			&i.ID,
			&i.Author,
			&i.Message,
			pq.Array(&i.UserIdsWhoLikes),
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingTodayPostIDs = `-- name: GetTrendingTodayPostIDs :many
WITH p AS (
	SELECT id FROM posts
	WHERE created_at > current_timestamp - interval '1 day'
	ORDER BY likes DESC
	LIMIT 30
)
SELECT id FROM p 
ORDER BY RANDOM()
LIMIT 10
`

func (q *Queries) GetTrendingTodayPostIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingTodayPostIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingTodayPosts = `-- name: GetTrendingTodayPosts :many
WITH p AS (
	SELECT likes, audio, id, author, message, user_ids_who_likes, created_at FROM posts
	WHERE created_at > current_timestamp - interval '1 day'
	ORDER BY likes DESC
	LIMIT 30
)
SELECT likes, audio, id, author, message, user_ids_who_likes, created_at FROM p 
ORDER BY RANDOM()
LIMIT 10
`

type GetTrendingTodayPostsRow struct {
	Likes           sql.NullInt32
	Audio           json.RawMessage
	ID              string
	Author          string
	Message         string
	UserIdsWhoLikes []string
	CreatedAt       sql.NullTime
}

func (q *Queries) GetTrendingTodayPosts(ctx context.Context) ([]GetTrendingTodayPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingTodayPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrendingTodayPostsRow
	for rows.Next() {
		var i GetTrendingTodayPostsRow
		if err := rows.Scan(
			&i.Likes,
			&i.Audio,
			&i.ID,
			&i.Author,
			&i.Message,
			pq.Array(&i.UserIdsWhoLikes),
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasUserLikedPost = `-- name: HasUserLikedPost :one
SELECT EXISTS(SELECT 1 FROM posts WHERE id=$1 AND $2::VARCHAR(100)=ANY(user_ids_who_likes::VARCHAR(100)[]))
`

type HasUserLikedPostParams struct {
	ID      string
	Column2 string
}

func (q *Queries) HasUserLikedPost(ctx context.Context, arg HasUserLikedPostParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserLikedPost, arg.ID, arg.Column2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const likePost = `-- name: LikePost :one

UPDATE posts
SET
likes = likes + 1,
user_ids_who_likes = array_append(user_ids_who_likes,$1::VARCHAR(100))
WHERE id = $2
RETURNING likes, audio, id, author, message, user_ids_who_likes, created_at
`

type LikePostParams struct {
	Column1 string
	ID      string
}

// TODO: pagination
func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.Column1, arg.ID)
	var i Post
	err := row.Scan(
		&i.Likes,
		&i.Audio,
		&i.ID,
		&i.Author,
		&i.Message,
		pq.Array(&i.UserIdsWhoLikes),
		&i.CreatedAt,
	)
	return i, err
}

const removeLikeFromPost = `-- name: RemoveLikeFromPost :one
UPDATE posts
SET
likes = likes - 1,
user_ids_who_likes = array_remove(user_ids_who_likes,$1::VARCHAR(100))
WHERE id = $2
RETURNING likes, audio, id, author, message, user_ids_who_likes, created_at
`

type RemoveLikeFromPostParams struct {
	Column1 string
	ID      string
}

func (q *Queries) RemoveLikeFromPost(ctx context.Context, arg RemoveLikeFromPostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, removeLikeFromPost, arg.Column1, arg.ID)
	var i Post
	err := row.Scan(
		&i.Likes,
		&i.Audio,
		&i.ID,
		&i.Author,
		&i.Message,
		pq.Array(&i.UserIdsWhoLikes),
		&i.CreatedAt,
	)
	return i, err
}
