// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package comments

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
)

const createComment = `-- name: CreateComment :one
INSERT INTO comments (id, message, audio, author, parent_id, likes, post_id, thread_type, thread_target_id)
VALUES ($1, $2, $3, $4, $5, 0, $6, $7, $8)
RETURNING likes, audio, author, parent_id, post_id, thread_type, id, thread_target_id, message, user_ids_who_likes
`

type CreateCommentParams struct {
	ID             string
	Message        sql.NullString
	Audio          json.RawMessage
	Author         string
	ParentID       sql.NullString
	PostID         string
	ThreadType     string
	ThreadTargetID sql.NullString
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.ID,
		arg.Message,
		arg.Audio,
		arg.Author,
		arg.ParentID,
		arg.PostID,
		arg.ThreadType,
		arg.ThreadTargetID,
	)
	var i Comment
	err := row.Scan(
		&i.Likes,
		&i.Audio,
		&i.Author,
		&i.ParentID,
		&i.PostID,
		&i.ThreadType,
		&i.ID,
		&i.ThreadTargetID,
		&i.Message,
		pq.Array(&i.UserIdsWhoLikes),
	)
	return i, err
}

const getComments = `-- name: GetComments :many
SELECT likes, audio, author, parent_id, post_id, thread_type, id, thread_target_id, message, user_ids_who_likes FROM comments c WHERE c.post_id = $1 AND c.thread_type = 'post'
UNION ALL
(SELECT likes, audio, author, parent_id, post_id, thread_type, id, thread_target_id, message, user_ids_who_likes FROM comments z WHERE z.post_id = $1 AND thread_type != 'post' ORDER BY likes DESC)
`

func (q *Queries) GetComments(ctx context.Context, postID string) ([]Comment, error) {
	rows, err := q.db.QueryContext(ctx, getComments, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.Likes,
			&i.Audio,
			&i.Author,
			&i.ParentID,
			&i.PostID,
			&i.ThreadType,
			&i.ID,
			&i.ThreadTargetID,
			&i.Message,
			pq.Array(&i.UserIdsWhoLikes),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasUserLikedComment = `-- name: HasUserLikedComment :one
SELECT EXISTS(SELECT 1 FROM comments WHERE id=$1 AND $2::VARCHAR(100)=ANY(user_ids_who_likes::VARCHAR(100)[]))
`

type HasUserLikedCommentParams struct {
	ID      string
	Column2 string
}

func (q *Queries) HasUserLikedComment(ctx context.Context, arg HasUserLikedCommentParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserLikedComment, arg.ID, arg.Column2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const likeComment = `-- name: LikeComment :one
UPDATE comments
SET
likes = likes + 1,
user_ids_who_likes = array_append(user_ids_who_likes,$1::VARCHAR(100))
WHERE id = $2::VARCHAR(100)
RETURNING likes, audio, author, parent_id, post_id, thread_type, id, thread_target_id, message, user_ids_who_likes
`

type LikeCommentParams struct {
	UserID string
	ID     string
}

func (q *Queries) LikeComment(ctx context.Context, arg LikeCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, likeComment, arg.UserID, arg.ID)
	var i Comment
	err := row.Scan(
		&i.Likes,
		&i.Audio,
		&i.Author,
		&i.ParentID,
		&i.PostID,
		&i.ThreadType,
		&i.ID,
		&i.ThreadTargetID,
		&i.Message,
		pq.Array(&i.UserIdsWhoLikes),
	)
	return i, err
}

const removeLikeFromComment = `-- name: RemoveLikeFromComment :one
UPDATE comments
SET
likes = likes - 1,
user_ids_who_likes = array_remove(user_ids_who_likes,$1::VARCHAR(100))
WHERE id = $2::VARCHAR(100)
RETURNING likes, audio, author, parent_id, post_id, thread_type, id, thread_target_id, message, user_ids_who_likes
`

type RemoveLikeFromCommentParams struct {
	UserID string
	ID     string
}

func (q *Queries) RemoveLikeFromComment(ctx context.Context, arg RemoveLikeFromCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, removeLikeFromComment, arg.UserID, arg.ID)
	var i Comment
	err := row.Scan(
		&i.Likes,
		&i.Audio,
		&i.Author,
		&i.ParentID,
		&i.PostID,
		&i.ThreadType,
		&i.ID,
		&i.ThreadTargetID,
		&i.Message,
		pq.Array(&i.UserIdsWhoLikes),
	)
	return i, err
}
